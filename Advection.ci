mainmodule Main {
  readonly CProxy_Main main_proxy;
  readonly CProxy_MeshBlock mesh;
  readonly int grid_height;
  readonly int grid_width;
  readonly int grid_depth;
  readonly int block_height;
  readonly int block_width;
  readonly int block_depth;
  readonly int n_chares_x;
  readonly int n_chares_y;
  readonly int n_chares_z;
  readonly int min_depth;
  readonly int max_depth;
  readonly float x_ctr;
  readonly float y_ctr;
  readonly float z_ctr;
  readonly float radius;
  readonly float vx;
  readonly float vy;
  readonly float vz;
  readonly float apx;
  readonly float anx;
  readonly float apy;
  readonly float any;
  readonly float apz;
  readonly float anz;
  readonly float tmax;
  readonly float dt;
  readonly float cfl;
  readonly int max_iters;
  readonly int refine_freq;
  readonly int lb_freq;
  readonly bool verbose;

  readonly CProxy_MeshManager mesh_manager;

  mainchare [migratable] Main {
    entry Main(CkArgMsg *m);
    entry void terminate();
    entry void startMeshGeneration();
    entry [reductiontarget] void totalWorkUnits(int total);
  };

  group [migratable] AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection {
  class Neighbor;

  group [migratable] MeshManager {
    entry MeshManager();
    entry void reduceWorkUnits();
    entry void meshGenerationPhaseIsOver();
    entry void incrementWorkUnitCount(int);
    entry void recvChildLogs(map<int, pair<float, float>> peQdtimes,
                             map<int, pair<float, float>> peRemeshtimes,
                             map<int, int> peWorkunits,
                             map<int, int> peminLoad,
                             map<int, int> pemaxLoad,
                             map<int, float> peavgLoad);
    entry void reduceQdTimes() {
      serial {
        for (map<int, int>::iterator it = workUnits.begin(); it != workUnits.end(); it++) {
          if (it->first % lb_freq == 0 || it->first % lb_freq == lb_freq-1) {
            // Load balancing iteration
            minLoad[it->first] = workUnits[it->first];
            maxLoad[it->first] = workUnits[it->first];
            avgLoad[it->first] = workUnits[it->first];
          }
        }
      }
      if (2*CkMyPe()+1 < CkNumPes()) {
        when recvChildLogs(map<int, pair<float, float>> peQdtimes,
                           map<int, pair<float, float>> peRemeshtimes,
                           map<int, int> peWorkunits,
                           map<int, int> peminLoad,
                           map<int, int> pemaxLoad,
                           map<int, float> peavgLoad)
        serial {
          processQdTimes(peQdtimes, peRemeshtimes, peWorkunits, peminLoad, pemaxLoad, peavgLoad);
        }
      }
      if (2*CkMyPe()+2 < CkNumPes()) {
        when recvChildLogs(map<int, pair<float, float> > peQdtimes,
                           map<int, pair<float, float> > peRemeshtimes,
                           map<int, int> peWorkunits,
                           map<int, int> peminLoad,
                           map<int, int> pemaxLoad,
                           map<int, float> peavgLoad) serial {
          processQdTimes(peQdtimes, peRemeshtimes, peWorkunits, peminLoad, pemaxLoad, peavgLoad);
        }
      }
      serial {
        if (CkMyPe() == 0) {
          printLogs();
        }
        else {
          thisProxy[(CkMyPe()-1)/2].recvChildLogs(qdtimes, remeshtimes, workUnits, minLoad, maxLoad, avgLoad);
        }
      }
    };
  };

  array [OctIndex] MeshBlock {
    entry MeshBlock();
    entry MeshBlock(float, float, float, float, float, float);
    // This constructor is used when a new chare is constructed upon refinement
    entry MeshBlock(float, float, float, float, float, float, float, float,
                    int, int, std::vector<float>, std::map<OctIndex, Neighbor> neighbors);

    // For exchanging boundary layers
    entry void receiveGhosts(int iter, int dir, int quadrant, int width, float u[width]);
    entry void signalExchangeGhostsCompletion();

    // Remeshing phase 1
    entry void informParent(int, int, Decision, int cascade_length);
    entry void recvParentDecision(int, int cascade_length);
    entry void exchangePhase1Msg(int, int, int, Decision, int cascade_length);

    // Remeshing phase 2
    entry void startPhase2(int);
    entry void recvChildData(int, float, float, int, int, std::vector<float>,
                             std::map<OctIndex, Neighbor> neighbors,
                             std::map<OctIndex, Decision> uncleDecisions);
    entry void recvChildData(int, int, float, float, int, int, std::vector<float>,
                             std::map<OctIndex, Neighbor> neighbors,
				                     std::map<OctIndex, Decision> uncleDecisions);
    entry void startLdb();
    entry void phase1Finish() {
      serial {
        // Inform everybody that phase 1 is over
        thisProxy.startPhase2(meshGenIterations);
      }
    };

    // Specifies control flow of the remeshing phase
    entry void doRemeshing() {
      serial {
        remeshStartTime = CmiWallTimer();
        if (isRoot()) {
          ckout << "Remeshing now... iteration: " << iterations
            << ", meshGenIterations: " << meshGenIterations << endl;
        }
        logfile << "Remeshing, meshGenIterations: " << meshGenIterations << std::endl;
        if (/*!inInitialMeshGenerationPhase*/ meshGenIterations > max_depth && isLeaf) {
          thisProxy[thisIndex].exchangeGhosts();
        }
        else {
          signalExchangeGhostsCompletion();
        }
      }
      // Remeshing takes place in two phases. In phase 1, each chare makes a granularity
      // decision based on the error estimator and communicates the decision to its neighbors.
      // Chares update their granularity decision based on their neighbor messages in order to
      // maintain the level difference restriction between neighboring blocks (refinement is
      // given highest priority followed by the stay decision). These decisions may propagate
      // across the mesh. Quiescence detector is started to figure out when all the chares have
      // come to a consensus about their granularity decisions.
      when signalExchangeGhostsCompletion() {
        serial {
          VB(logfile << "Registering QD, isLeaf: " << isLeaf << std::endl;);
          makeGranularityDecisionAndCommunicate();
          if (isRoot()) {
            if (iterations % lb_freq == 0 && iterations >= 1) {
              CkStartQD(CkCallback(CkIndex_MeshBlock::startLdb(), thisProxy));
            }
            else {
              CkStartQD(CkCallback(CkIndex_MeshBlock::phase1Finish(), thisProxy[thisIndex]));
            }
          }
        }
      }
      // In phase 2, the blocks which need to be refined interpolate their data and create new
      // children chares. Chares to be coarsened send their data to the parent and destroy
      // themselves. The completion of this phase is again detected by a quiescence detector.
      while (!phase1Over) {
        serial {
          lastBusyTime = CmiWallTimer();
          VB(logfile << "In while loop, meshGenIterations: " << meshGenIterations << std::endl;);
        }
        case {
          when exchangePhase1Msg[meshGenIterations](int iterations, int dir,
                                                    int quad, Decision dec, int length) {
            serial {
              VB(logfile << "Iteration: " << iterations << std::endl;);
              processPhase1Msg(dir, quad, dec, length);
              VB(logfile << "Out of processPhase1Msg" << std::endl;);
              lastBusyTime = CmiWallTimer();
            }
          }

          when recvParentDecision[meshGenIterations](int iterations, int length) {
            serial {
              VB(logfile << "recvd message from parent" << std::endl;);
              processParentDecision(length);
              lastBusyTime = CmiWallTimer();
            }
          }

          when informParent[meshGenIterations](int iterations, int cnum, Decision dec, int length) {
            serial {
              VB(logfile << "recvd message from child " << thisIndex.getChild(cnum).getIndexString()
                 << ", iterations " << meshGenIterations << std::endl;);
              processChildDecision(cnum, dec, length);
              lastBusyTime = CmiWallTimer();
            }
          }

          when startPhase2[meshGenIterations](int meshgeniter) {
            serial {
              lastIdleTime = CmiWallTimer();
              mesh_manager_local->recordQdTime(meshGenIterations, lastBusyTime, lastIdleTime);
              if (isRoot()) {
                ckout << "Starting phase 2, iteration: " << meshgeniter << ", meshGenIterations: "
                  << meshGenIterations << endl;
              }
              VB(logfile << "QD detected: phase 1 over" << std::endl;
                 logfile << "Decision: " << decision << std::endl;);
              doPhase2();
              phase1Over = true;
            }
          }
        }
      }
      serial {
        phase1Over = false;
      }
    };

    entry void doComputationStep() {
      serial {
        if (isLeaf) {
          mesh_manager_local->incrementWorkUnitCount(iterations);
        }
        if (isRoot()) {
          ckout << "Starting iteration " << iterations << " at root, time: " << CmiWallTimer() << endl;
        }
        // Only the leaf chares participate in boundary exchange,
        // others just indicate boundary exchange completion
        if (isLeaf) {
          thisProxy[thisIndex].exchangeGhosts();
        }
        else {
          thisProxy[thisIndex].signalExchangeGhostsCompletion();
        }
      }
      when signalExchangeGhostsCompletion() serial {
        // Only the leaf chares do the computation,
        // others just move on to the next iteration
        if(isLeaf) {
          compute();
        }
        else {
          iterate();
        }
      }
    };

    entry void computeDone();

    // In the initial mesh generation phase, the mesh keeps on remeshing itself
    // until it has reached a stable state based on the error estimate for the
    // initial conditions. After this phase is over, remeshing occurs after a certain
    // number of iterations (defined by refine_freq).
    entry void iterate() {
      serial {
        if (/*inInitialMeshGenerationPhase*/ meshGenIterations++ < max_depth) {
          thisProxy[thisIndex].doRemeshing();
        }
        else {
          if (isRoot()) {
            mesh_manager.meshGenerationPhaseIsOver();
          }
          if (iterations % refine_freq == 0) { // last one was a remeshing phase
            remeshEndTime = CmiWallTimer();
            mesh_manager_local->recordRemeshTime(iterations, remeshStartTime, remeshEndTime);
          }
          iterations++;
          myt = myt + mydt;
          if (iterations > max_iters || myt >= tmax) {
            if (isRoot()) {
              CkStartQD(CkCallback(CkIndex_Main::terminate(), main_proxy));
            }
            return;
          }
          mydt = min(dx, min(dy, dz)) / sqrt(vx * vx + vy * vy + vz * vz) * cfl;
          if ((myt + mydt) >= tmax) {
            mydt = tmax - myt;
          }

          if (iterations % refine_freq == 0) {
            thisProxy[thisIndex].doRemeshing(); // time to do remeshing
          }
          else {
            thisProxy[thisIndex].doComputationStep();
          }
        }
      }
    };

    entry void printSelf() {
      if (isLeaf) {
        atomic {
          printData();
        }
      }
      else {
        for (amr3d_i = 0; amr3d_i < NUM_CHILDREN; amr3d_i++) {
          atomic {
            mesh(thisIndex.getChild(amr3d_i)).printSelf();
          }
          when donePrinting() {}
        }
      }
    };

    entry void donePrinting();

    entry void exchangeGhosts() {
      serial {
        prepareData4Exchange();

        // Send boundaries to neighbors which are on the same level as you, and to your
        // uncles. For the neighbors which are your nephews, wait until they send their
        // boundaries, then interpolate and send back the interpolated boundaries.
        for (int i = 0; i < NUM_NEIGHBORS; i++) {
          sendGhost(i);
        }
      }

      while (imsg < 6) {
        when receiveGhosts[iterations](int iter, int dir, int quadrant, int width, float u1[width]) {
          serial {
            process(iter, dir, quadrant, width, u1);
            sendReadyData(); // send interpolated data to nephews
          }
        }
      }

      serial {
        thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
    };

    entry void wait4ChildData() {
      serial {
        mem_allocate_all();
      }

      for (ichild = 0; ichild < NUM_CHILDREN; ichild++) {
        serial {
          VB(logfile << "Waiting for child data, meshGenIterations: " << meshGenIterations << std::endl;);
        }
        when recvChildData[meshGenIterations](int iter, int a, float b, float c, int d, int e,
                                              std::vector<float> f, std::map<OctIndex, Neighbor> g,
                                              std::map<OctIndex, Decision> h) {
          serial {
            recvChildData(a, b, c, d, e, f, g, h);
          }
        }
      }

      serial {
        iterate();
      }
    };

    entry void gotErrorFromGPU();
  };
};
