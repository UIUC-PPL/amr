mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly CProxy_Advection qtree;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;

  initproc TurnManualLBOn();
  readonly CProxy_AdvectionGroup ppc;
  readonly bool isInMeshGenerationPhase;

  mainchare Main{
    entry Main(CkArgMsg *m);
    entry void terminate();
    entry void startMeshGeneration();
    entry [reductiontarget] void totalWorkUnits(int total);
  };

  group AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  group AdvectionGroup{
    entry AdvectionGroup();
    entry void reduceWorkUnits();
    entry void meshGenerationPhaseIsOver();
    entry void incrementWorkUnitCount();
  };


  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(double, double, double, double,
                    double, double, int, int, std::vector<double>,
                    bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                    Decision p3[3*NUM_NEIGHBORS]);
    entry void receiveGhosts(int iter, int dir, int width, double u[width]);
    entry void informParent(int, Decision, int cascade_length);
    entry void recvParentDecision(int cascade_length);
    entry void exchangePhase1Msg(int, Decision, int cascade_length);
    entry void startLdb();
    entry void signalExchangeGhostsCompletion();
    entry void startPhase2();
    entry void recvChildData(int, double, double, int, int, std::vector<double>, 
                            bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                            Decision p3[3*NUM_NEIGHBORS]);

    entry void doRemeshing() {
      atomic {
        if (!isInMeshGenerationPhase && isLeaf) exchangeGhosts();
        else signalExchangeGhostsCompletion();
      }
      when signalExchangeGhostsCompletion() atomic{
          makeGranularityDecisionAndCommunicate();
          CkStartQD(CkCallback(CkIndex_Advection::startPhase2(), thisProxy[thisIndex]));
      }
      when startPhase2() atomic{
        doPhase2();
        if (isRoot()) CkStartQD(CkCallback(CkIndex_Advection::iterate(), thisProxy));
      }
    };


    entry void doComputationStep(){
      atomic {
        ppc.ckLocalBranch()->incrementWorkUnitCount();
        if (isRoot())
            ckout  << "starting iteration " << iterations << " at root, time = " << CmiWallTimer() << endl;
        if(isLeaf) exchangeGhosts();
        else thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
      when signalExchangeGhostsCompletion() atomic {
        if(isLeaf) compute();
        iterate();
      }
    };

    entry void iterate() atomic {
      if(isInMeshGenerationPhase && meshGenIterations<max_depth){
        meshGenIterations++;
        thisProxy[thisIndex].doRemeshing();
      } else {
        if (isRoot()) ppc.meshGenerationPhaseIsOver();
        iterations++;
        myt = myt + mydt;
        if(iterations > max_iterations ||  myt>=tmax){
          if (isRoot()) CkStartQD(CkCallback(CkIndex_Main::terminate(), mainProxy));
          return;
        }
        mydt = min(dx,dy)/v * cfl;
        if ((myt + mydt) >= tmax )
          mydt = tmax - myt;
        sprintf(fname, "out/out_%s_%d", thisIndex.getIndexString().c_str(), iterations);
        VB(outFile.open(fname););

        if(iterations % refine_frequency == 0) doRemeshing();
        else doComputationStep();
      }
    };

    entry void exchangeGhosts(){
      atomic {
        for(int i=0; i<3*NUM_NEIGHBORS; i++)
          nbr_dataSent[i]=false;

        hasReceived.clear();

        for(int j=1; j<=block_height; j++){
          left_edge[j-1] = u[index(1,j)];
          right_edge[j-1] = u[index(block_width,j)];
        }
        FOR_EACH_NEIGHBOR
          sendGhost(i);
        END_FOR
      }

      for(imsg = 0; imsg < 4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width]) atomic {
          process(iter, dir, width, u1);
          sendReadyData();
        }
      }
      atomic { thisProxy[thisIndex].signalExchangeGhostsCompletion(); }
    };

  };
};
