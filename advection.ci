mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly int nframe;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;

  mainchare Main{
    entry Main(CkArgMsg *m);
    entry void printTreeInformation(CkVec<QuadIndex>);
    entry void terminate();
    entry void startRunning();
  };

  group AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  message InitRefineMsg {
    double dx;
    double dy;
    double myt;
    double mydt;
    double refined_u[];
    bool parent_nbr_exists[];
    bool parent_nbr_isRefined[];
    DECISION parent_nbr_decision[];
  };

  message ChildDataMsg{
    int childNum;
    int iterations;
    double myt;
    double mydt;
    double child_u[];
    bool child_nbr_exists[];
    bool child_nbr_isRefined[];
    DECISION child_nbr_decision[];
  };


  group PerProcessorChare{
    entry PerProcessorChare();

  };

  //include "terminator.hpp";

  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(InitRefineMsg*);
    entry void printState();

    entry void receiveGhosts(int iter, int dir, int width, double u[width], QuadIndex sender, int tag);
    entry void begin_iteration();
    entry void informParent(int, DECISION);
    entry void recvParentDecision();
    //entry void recvNeighborDecision(DIR);
    //entry void recvStatusUpdateFromParent(int);
    entry void exchangePhase1Msg(int, DECISION);
    //entry void doMeshRestructure();
    entry void done();

    entry void rootTerminated() {};
    entry void startRemesh() {
        atomic "doMeshRestructure" {
          doMeshRestructure();
          if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0)
            CkStartQD(CkCallback(CkIndex_Advection::phase1Done(), thisProxy));
        }

        	when phase1Done() atomic {
	  			if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
	    			CkPrintf("%s in phase 2a iteration start QD %d\n", thisIndex.getIndexString().c_str(), iterations);
            		CkStartQD(CkCallback(CkIndex_Advection::phase2Done(), thisProxy));
	  			}
          		doPhase2();
        	}
    };

    // Separated for newly created chares from refinement
    entry  [reductiontarget] void phase2Done() {
		atomic {
			if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
	  			CkPrintf("%s in phase 2c iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
	  			fflush(stdout);
			}
        	if (shouldDestroy) 
				thisProxy[thisIndex].ckDestroy();
        	else {
          		if (!isRefined) {
            		thisProxy[thisIndex].doStep();
          		} 
				else {
            		iterations += refine_frequency;
	    			if (iterations >= max_iterations) {
	      				//ckout << thisIndex.getIndexString().c_str() << " now terminating" << endl;
		  				VB(logFile << thisIndex.getIndexString() << " now terminating" << std::endl;);
		  				contribute(CkCallback(CkIndex_Main::terminate(), mainProxy));
	    			} else {
	      				if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
							CkPrintf("%s in short phase 0 iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
							fflush(stdout);
	      				}
	      				contribute(CkCallback(CkIndex_Advection::startRemesh(), thisProxy));
	    			}
            		//startRemesh();
          		}
        	}
      	}
    };

    entry void doStep(){
      atomic "begin iteration"{
	if (thisIndex.bitVector == 0) {
	  ckout  << thisIndex.getIndexString().c_str() << " doStep iteration " << iterations << endl;
	}
        iterations++;
        begin_iteration();
      }
      for(imsg = 0; imsg < 4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                        QuadIndex sender, int tag) atomic "process ghosts" {
          VB(logFile << thisIndex.getIndexString() << " process: " << iter << ", "
                     << dir << ", " << width << ", " << sender.getIndexString() << ", "
                     << tag << std::endl;);
          process(iter, dir, width, u1);
          sendReadyData();
        }
      }
      atomic "doWork" {
        compute_and_iterate();
        iterate();
      }
    };
    entry void phase1Done();
            
    entry void getGhostsAndRefine(){
      /*atomic "initialize imsg"{
        imsg=0;
        for(set<int>::iterator itr=hasReceived.begin(); itr!=hasReceived.end(); itr++){
        if(*itr <= 3)
        imsg++;
        else 
        imsg += 0.5;
        }
        }*/
      for(;imsg<4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                        QuadIndex sender, int tag) atomic "save ghosts" {
          process(iter, dir, width, u1);
          sendReadyData2RefiningNeighbors();
          //cout << "In getGHostsAndRefine: " << thisIndex.getIndexString()
          //<< " received data from " << dir << ", imsg: " << imsg << ", iteration " << iterations << "\n";
          ////terminator->doneSending();
          ////terminator->msgProcessed();
        }
      }
      atomic "refine"{
        //cout << thisIndex.getIndexString() << " now refining\n";
        refine();
        ////terminator->doneSending();
        ////terminator->msgProcessed(); // For the self-message that triggered this
      }
    };
    //happens in doPhase2()
    entry void receiveRefGhosts(int ,int, int width, double u[width]);
    entry void getAndSendGhost(){
      atomic{
        VB(logFile << "getAndSendGhost called" << endl;); 
        ////terminator->msgProcessed(); // For the self-message that triggered this
      }
      when receiveRefGhosts[iterations] (int iter, int dir, int width,
                                         double u1[width]) atomic "interpolate and send"{
        process(iter, dir, width, u1);
        sendReadyData2RefiningNeighbors();//interpolateAndSend(dir);
        ////terminator->doneSending();
        ////terminator->msgProcessed();
      }
    };

    //for LiveViz
    entry void requestNextFrame(liveVizRequestMsg *m);
    entry void free_memory();
    entry void doPhase2();
    entry void recvChildData(ChildDataMsg*);

    /*// For termination detection
    entry void needAck(QuadIndex predecessor, unsigned int count);
    entry void gotAck(unsigned int count);*/
  };
};
