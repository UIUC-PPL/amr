mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly CProxy_Advection qtree;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;

  initproc TurnManualLBOn();
  readonly CProxy_PerProcessorChare ppc;
    
  readonly bool isInMeshGenerationPhase;
  mainchare Main{
    entry Main(CkArgMsg *m);
    //entry void printTreeInformation(CkVec<QuadIndex>);
    entry void terminate();
    entry void startMeshGeneration();
    //entry void startRunning();
    entry [reductiontarget] void reportCascadeStats(int cascade_lengths[size], int size);
    entry [reductiontarget] void qdlatency(double elems[size], int size);
    entry [reductiontarget] void remeshlatency(double elems[size], int size);
    entry [reductiontarget] void totalWorkUnits(int total);
  };

  group AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  group PerProcessorChare{
    entry PerProcessorChare();
    entry void collectCascades(CkCallback cb);
    entry void reduceLatencies();
    entry void reduceWorkUnits();
    entry void meshGenerationPhaseIsOver();
    entry void notifyMeshUpdate(DECISION);
    entry [reductiontarget] void meshUpdateReductionClient(int);
    entry void resetMeshUpdateCounters();
  };


  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(double, double, double, double,
                    double, double, int, int, std::vector<double>,
                    bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                    DECISION p3[3*NUM_NEIGHBORS]);
    entry void printState();

    entry void receiveGhosts(int iter, int dir, int width, double u[width]);
    entry void informParent(int, DECISION, int cascade_length);
    entry void recvParentDecision(int cascade_length);
    entry void exchangePhase1Msg(int, DECISION, int cascade_length);

    entry void rootTerminated() {};
    
    entry void doRemeshing(){
        if(!isInMeshGenerationPhase && !isRefined) {
            atomic "trigger ghost exchange"{
                exchangeGhosts();
            }
        }
        else {
            atomic "signal exchange ghost completion without actually doing it"{
                if(isRoot() && isInMeshGenerationPhase){ckout << "in mesh generation phase" << endl;}
                VB(logFile << "in mesh gen iter" << std::endl;);
                thisProxy[thisIndex].signalExchangeGhostsCompletion();
            }
        }
        when signalExchangeGhostsCompletion() atomic "start error estimation and phase1 QD"{
            makeGranularityDecisionAndCommunicate();
            CkStartQD(CkCallback(CkIndex_Advection::phase1Done(), thisProxy[thisIndex]));
        }

        when phase1Done() atomic "start phase2"{
          double now = CkWallTimer();
          double localQDLatency = now - lastIdleTimeQD;
          double localRemeshLatency = now - remeshStartTime;
          ppc.ckLocalBranch()->recordQDLatency(iterations, localQDLatency);
          ppc.ckLocalBranch()->recordRemeshLatency(iterations, localRemeshLatency);

          if(isRoot()) ckout << "in doPhase2" << endl;
          doPhase2();
          resetMeshRestructureData();
          if(isRoot()){
              CkStartQD(CkCallback(CkIndex_Advection::phase2Done(), thisProxy));
          }
        }
    };

    entry void phase2Done() atomic "done phase2"{
        if(isInMeshGenerationPhase){
            meshGenIterations++;
            if(ppc.ckLocalBranch()->meshUpdated && meshGenIterations<20){
                thisProxy[thisIndex].doRemeshing();
                ppc.ckLocalBranch()->resetMeshUpdateCounters();
                return;
            }
        }
        isInMeshGenerationPhase=false;
        if(isRoot())ppc.meshGenerationPhaseIsOver();
        if(isInMeshGenerationPhase && isRefined) iterations=1;
        if(isRoot()){
            itBeginTime=CmiWallTimer();
        }
        if(!isRefined)
            thisProxy[thisIndex].doStep();
        else{
          iterations += refine_frequency - 1;
          if (iterations >= max_iterations) {
            VB(logFile << thisIndex.getIndexString() << " now terminating" << std::endl;);
            if (isRoot())
              CkStartQD(CkCallback(CkIndex_Main::terminate(), mainProxy));
          } 
          else {
            doRemeshing();
          }
        }
    };

    entry void makeGranularityDecisionAndCommunicate();
    entry void startLdb();
    entry void signalExchangeGhostsCompletion();

    entry void doStep(){
      atomic "begin iteration"{
        ppc.ckLocalBranch()->incrementWorkUnitCount();
        if (isRoot()) {
          ckout  << thisIndex.getIndexString().c_str() << " doStep iteration " << iterations 
                 << " dt: " << dt << " mydt: " << mydt << " myt " << myt << endl;
        }
        iterations++;
        char fname[100];

        sprintf(fname, "out/out_%s_%d", thisIndex.getIndexString().c_str(), iterations);
        VB(outFile.open(fname););
        VB(logFile << "************************Begin Iteration " << iterations << " on " << thisIndex.getIndexString() << std::endl;);

        exchangeGhosts();
      }
      when signalExchangeGhostsCompletion() atomic "doWork" {
        compute();
        iterate();
      }
    };

    entry void exchangeGhosts(){
      atomic "send whatever data you can"{
        for(int i=0; i<3*NUM_NEIGHBORS; i++)
          nbr_dataSent[i]=false;

        hasReceived.clear();

        for(int j=1; j<=block_height; j++){
          left_edge[j-1] = u[index(1,j)];
          right_edge[j-1] = u[index(block_width,j)];
        }
        FOR_EACH_NEIGHBOR
          sendGhost(i);
        END_FOR
        VB(logFile << "Done Sending Ghosts " << thisIndex.getIndexString() << std::endl;);
      }

      for(imsg = 0; imsg < 4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width]) atomic "receive ghosts" {
          VB(logFile << thisIndex.getIndexString() << " process: " << iter << ", "
             << dir << ", " << width << std::endl;);
          process(iter, dir, width, u1);
          sendReadyData();
        }
      }
      atomic "signal exchange ghost completion"{
        thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
    };

    entry void phase1Done();
    entry void free_memory();
    entry void doPhase2();
    entry void recvChildData(int, double, double, int, int, std::vector<double>, bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], DECISION p3[3*NUM_NEIGHBORS]);

  };
};
