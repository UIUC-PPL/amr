mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly int nframe;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;

  mainchare Main{
    entry Main(CkArgMsg *m);
    entry void printTreeInformation(CkVec<QuadIndex>);
    entry void terminate();
    entry void startMeshGeneration();
    entry void startRunning();
  };

  group AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  message InitRefineMsg {
    double dx;
    double dy;
    double myt;
    double mydt;
    double refined_u[];
    bool parent_nbr_exists[];
    bool parent_nbr_isRefined[];
    DECISION parent_nbr_decision[];
  };

  message ChildDataMsg{
    int childNum;
    int iterations;
    double myt;
    double mydt;
    double child_u[];
    bool child_nbr_exists[];
    bool child_nbr_isRefined[];
    DECISION child_nbr_decision[];
  };


  group PerProcessorChare{
    entry PerProcessorChare();

  };

  //include "terminator.hpp";

  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(InitRefineMsg*);
    entry void printState();

    entry void receiveGhosts(int iter, int dir, int width, double u[width], QuadIndex sender, int tag);
    entry void begin_iteration();
    entry void informParent(int, DECISION);
    entry void recvParentDecision();
    //entry void recvNeighborDecision(DIR);
    //entry void recvStatusUpdateFromParent(int);
    entry void exchangePhase1Msg(int, DECISION);
    entry void generateMesh();
    //entry void doMeshRestructure();
    entry void done();

    entry void rootTerminated() {};
    entry void startRemesh() {
        atomic "doMeshRestructure" {
          doMeshRestructure();
          if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0)
            CkStartQD(CkCallback(CkIndex_Advection::phase1Done(), thisProxy));
        }

				when phase1Done() atomic {
					if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
						CkPrintf("%s in phase 2a iteration start QD %d\n", thisIndex.getIndexString().c_str(), iterations);
						CkStartQD(CkCallback(CkIndex_Advection::phase2Done(), thisProxy));
					}
					doPhase2();
				}
    };

    // Separated for newly created chares from refinement
    entry  [reductiontarget] void phase2Done() {
		atomic {
			if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
	  		CkPrintf("%s in phase 2c iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
	  		fflush(stdout);
			}
      if (shouldDestroy) 
				thisProxy[thisIndex].ckDestroy();
      else {
         if (!isRefined) {
           thisProxy[thisIndex].doStep();
         } 
				else {
        	iterations += refine_frequency;
	    		if (iterations >= max_iterations) {
	      		//ckout << thisIndex.getIndexString().c_str() << " now terminating" << endl;
		  			VB(logFile << thisIndex.getIndexString() << " now terminating" << std::endl;);
		  			contribute(CkCallback(CkIndex_Main::terminate(), mainProxy));
	    		} else {
	      		if (thisIndex.nbits == min_depth * 2 && thisIndex.bitVector == 0) {
							CkPrintf("%s in short phase 0 iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
							fflush(stdout);
	      		}
	      		contribute(CkCallback(CkIndex_Advection::startRemesh(), thisProxy));
	    		}
          //startRemesh();
				}
			}
    }
	};
	entry void doRemeshing();
	entry void signalExchangeGhostsCompletion();

	entry void doStep(){
  	atomic "begin iteration"{
			if (thisIndex.bitVector == 0) {
	  		ckout  << thisIndex.getIndexString().c_str() << " doStep iteration " << iterations << endl;
			}
      iterations++;
      char fname[100];

      sprintf(fname, "out/out_%s_%d", thisIndex.getIndexString().c_str(), iterations);
      VB(outFile.open(fname););
      VB(logFile << "************************Begin Iteration " << iterations << " on " << thisIndex.getIndexString() << std::endl;);

			exchangeGhosts();
    }
		when signalExchangeGhostsCompletion() atomic "doWork" {
      compute_and_iterate();
      iterate();
    }
  };
	
	entry void doMeshRestructure(){
		if (!isRefined){
			atomic "exchange ghosts before remeshing"{
				exchangeGhosts();
			}
			when signalExchangeGhostsCompletion() atomic "do remeshing on leaves"{
				doRemeshing();
			}
		}
		else {
			atomic "do remeshing on internal nodes"{
				doRemeshing();
			}
		}
	};


  entry void exchangeGhosts(){
    atomic "send whatever data you can"{
			for(int i=0; i<3*NUM_NEIGHBORS; i++)
				nbr_dataSent[i]=false;
						
			hasReceived.clear();

			for(int j=1; j<=block_height; j++){
				left_edge[j-1] = u[index(1,j)];
				right_edge[j-1] = u[index(block_width,j)];
			}
			for(int i=0; i<NUM_NEIGHBORS; i++){
				sendGhost(i);
			}
			VB(logFile << "Done Sending Ghosts " << thisIndex.getIndexString() << std::endl;);
    }

    for(imsg = 0; imsg < 4;) {
    	when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                 QuadIndex sender, int tag) atomic "receive ghosts" {
      	VB(logFile << thisIndex.getIndexString() << " process: " << iter << ", "
                     << dir << ", " << width << ", " << sender.getIndexString() << ", "
                     << tag << std::endl;);
      	process(iter, dir, width, u1);
      	sendReadyData();
    	}
    }
		atomic "signal exchange ghost completion"{
			thisProxy[thisIndex].signalExchangeGhostsCompletion();
		}
  };

    entry void phase1Done();
            
    entry void getGhostsAndRefine(){
      /*atomic "initialize imsg"{
        imsg=0;
        for(set<int>::iterator itr=hasReceived.begin(); itr!=hasReceived.end(); itr++){
        if(*itr <= 3)
        imsg++;
        else 
        imsg += 0.5;
        }
        }*/
      for(;imsg<4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                        QuadIndex sender, int tag) atomic "save ghosts" {
          process(iter, dir, width, u1);
          sendReadyData2RefiningNeighbors();
          //cout << "In getGHostsAndRefine: " << thisIndex.getIndexString()
          //<< " received data from " << dir << ", imsg: " << imsg << ", iteration " << iterations << "\n";
          ////terminator->doneSending();
          ////terminator->msgProcessed();
        }
      }
      atomic "refine"{
        //cout << thisIndex.getIndexString() << " now refining\n";
        refine();
        ////terminator->doneSending();
        ////terminator->msgProcessed(); // For the self-message that triggered this
      }
    };
    //happens in doPhase2()
    entry void receiveRefGhosts(int ,int, int width, double u[width]);
    entry void getAndSendGhost(){
      atomic{
        VB(logFile << "getAndSendGhost called" << endl;); 
        ////terminator->msgProcessed(); // For the self-message that triggered this
      }
      when receiveRefGhosts[iterations] (int iter, int dir, int width,
                                         double u1[width]) atomic "interpolate and send"{
        process(iter, dir, width, u1);
        sendReadyData2RefiningNeighbors();//interpolateAndSend(dir);
        ////terminator->doneSending();
        ////terminator->msgProcessed();
      }
    };

    //for LiveViz
    entry void requestNextFrame(liveVizRequestMsg *m);
    entry void free_memory();
    entry void doPhase2();
    entry void recvChildData(ChildDataMsg*);

    /*// For termination detection
    entry void needAck(QuadIndex predecessor, unsigned int count);
    entry void gotAck(unsigned int count);*/
  };
};
