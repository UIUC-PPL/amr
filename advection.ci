mainmodule Main{

	readonly CProxy_Main mainProxy;
        readonly int block_height;
        readonly int block_width;

        readonly int array_height;
        readonly int array_width;

        readonly int num_chare_rows;
        readonly int num_chare_cols;

	readonly int nframe;

	readonly double xctr;
        readonly double yctr;
        readonly double radius;
        
        readonly double v;

        readonly double ap;
        readonly double an;
        readonly double tmax;
        readonly double dt;
        readonly double cfl;
        readonly int nx;
        readonly int ny;

        readonly map<string, DIR> nbrDirectionMap;
        readonly map<DIR, DIR> reverse_dir_map;
        mainchare Main{
            entry Main(CkArgMsg *m);
            entry void printTreeInformation(CkVec<QuadIndex>);
        };

        extern module Advection;
};

module Advection{

        message InitRefineMsg {
	    double dx;
	    double dy;
	    double myt;
	    double mydt;
            double refined_u[];
        };

	message ChildDataMsg{
	    int childNum;
	    double child_u[];
	};

        array [QuadIndex] Advection{
            entry Advection();
            entry Advection(double, double, double, double);
            entry Advection(InitRefineMsg*);
            entry void printState();

            entry void receiveGhosts(int iter, int dir, int width, double u[width]);
            entry void begin_iteration();
            entry void informParent(int, DECISION);
            entry void recvParentDecision();
            entry void recvNeighborDecision(DIR);
            entry void recvStatusUpdateFromParent(int);
            entry void exchangePhase1Msg(int);
            entry void doMeshRestructure();

            entry void doStep(){
                atomic "begin iteration"{
                    begin_iteration();
                }
                for(imsg = 0; imsg < 4;) {
                    // "iterations keep track of messages accross steps"
                    when 
                        receiveGhosts[iterations] (int iter, int dir, int width, double u[width])
                    atomic "process ghosts" {
                        process(iter, dir, width, u);
                        sendReadyData();
                    }
                }
                atomic "doWork" {
                    compute_and_iterate();
                }
            };
            
            entry void getGhostsAndRefine(){
                for(imsg=0; imsg<4;){
                    when 
                        receiveGhosts[iterations] (int iter, int dir, int width, double u[width])
                    atomic "save ghosts"{
                        process(iter, dir, width, u);
                    }
                }
                atomic "refine"{
                    refine();
                }
            };
            //for LiveViz
            entry void requestNextFrame(liveVizRequestMsg *m);
            entry void free_memory();
            entry void doPhase2();
            entry void recvChildData(ChildDataMsg*);
        };
};
