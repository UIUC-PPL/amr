mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly CProxy_Advection qtree;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;
  readonly int checkPTFreq;
  initproc TurnManualLBOn();
  readonly CProxy_AdvectionGroup ppc;
  readonly bool inInitialMeshGenerationPhase;

  mainchare [migratable] Main{
    entry Main(CkArgMsg *m);
    entry void terminate();
    entry void startMeshGeneration();
    //entry [reductiontarget] void totalWorkUnits(int total);
  };

  group [migratable] AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  group [migratable] AdvectionGroup{
    entry AdvectionGroup();
    //entry void reduceWorkUnits();
    entry void meshGenerationPhaseIsOver();
    //entry void incrementWorkUnitCount();
  };


  array [QuadIndex] Advection {
    //constructors
    entry Advection();
    entry Advection(double, double, double, double);
    //this constructor is used whena new chare is constructed upon refinement
    entry Advection(double, double, double, double,
                    double, double, int, int, std::vector<double>,
                    bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                    Decision p3[3*NUM_NEIGHBORS]);
    
    //entry methods for exchanging boundary layers
    entry void receiveGhosts(int iter, int dir, int width, double u[width]);
    entry void signalExchangeGhostsCompletion();

    //remeshing phase 1 entry methods
    entry void informParent(int, Decision, int cascade_length);
    entry void recvParentDecision(int cascade_length);
    entry void exchangePhase1Msg(int, Decision, int cascade_length);
    
    //remeshing phase 2 entry methods
    entry void startPhase2();
    entry void recvChildData(int, double, double, int, int, std::vector<double>, 
                            bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                            Decision p3[3*NUM_NEIGHBORS]);
    entry void startLdb();
    
    //sdag entry method that specifies the control flow 
    //of the Remeshing phase
    entry void doRemeshing() {
      serial {
        if(isRoot()) ckout << "doing remeshing now.." << endl;
        if (/*!inInitialMeshGenerationPhase*/ meshGenIterations>max_depth && isLeaf) exchangeGhosts();
        else signalExchangeGhostsCompletion();
      }
      //Remshing takes place in two phases:
      //in phase 1, each chare makes a granularity 
      //decision based on the error estimator and
      //communicates the decision to its neighbor
      //chares update their granularity decision
      //based on their neighbor messages in 
      //order to maintain the level difference
      //restriction between neighboring blocks
      //(refinement is given highest priority followed
      //by the stay decision). These decisions may
      //propagate across the mesh.
      //Quiesence detector is started to know
      //when all the chares have come to a consensus
      //about their granularity decision
      when signalExchangeGhostsCompletion() serial{
          makeGranularityDecisionAndCommunicate();
          CkStartQD(CkCallback(CkIndex_Advection::startPhase2(), thisProxy[thisIndex]));
      }
      //in phase 2, the  blocks which need to be
      //refined iterpolates its data, and creates new 
      //child chares. chares which are to be derefined
      //send their data to the parent and destroy themselves
      //completion of this phase is again detected by a 
      //Quiesence detector
      when startPhase2() serial{
		if(isRoot()) ckout << " in phase 2 " << endl;
        doPhase2();
        if (isRoot() && iterations%checkPTFreq==3) 
			CkStartQD(CkCallback(CkIndex_Advection::checkpoint(), thisProxy[thisIndex]));
		else if (isRoot() && iterations==12) 
			CkStartQD(CkCallback(CkIndex_Advection::killForFT(), thisProxy));
		else if(isRoot())
			CkStartQD(CkCallback(CkIndex_Advection::iterate(), thisProxy));
      }
    };
	entry void killForFT() serial{
		if (thisIndex.getIndexString()=="11100010"){
			CkPrintf("[%d] kill for FT\n",CkMyPe());
			CkDieNow();
		}
	};

	entry void checkpoint() serial{
		CkPrintf("[%d] start checkpoint\n",CkMyPe());
		CkCallback cb(CkIndex_Advection::iterate(),thisProxy);
		//CkStartCheckpoint("log",cb);
		CkStartMemCheckpoint(cb);
	};
    entry void doComputationStep(){
      serial {
        //ppc.ckLocalBranch()->incrementWorkUnitCount();
        if (isRoot())
            ckout  << "starting iteration " << iterations << " at root, time = " << CmiWallTimer() << endl;
        //only the leaf chares participate in boundary exchange,
        //others just indicate boundary exchange completion
        if(isLeaf) exchangeGhosts();
        else thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
      when signalExchangeGhostsCompletion() serial {
        //only the leaf chares do the computation
        //others just move on to the next iteration
        if(isLeaf) compute();
        iterate();
      }
    };

    entry void iterate() serial {
      //in the initial mesh generation phase
      //the mesh keeps on remeshing itself
      //until it has reached a stable state based
      //on the error estimate for the initial conditions
      //After the initialMeshGeneration phase is over
      //the program does remeshing after every refine_frequency
      //steps of computation
      if(/*inInitialMeshGenerationPhase && */meshGenIterations++ < max_depth){
        thisProxy[thisIndex].doRemeshing();
      } else {
        if (isRoot()) ppc.meshGenerationPhaseIsOver();
        iterations++;
        myt = myt + mydt;
        if(iterations > max_iterations ||  myt>=tmax){
          if (isRoot()) CkStartQD(CkCallback(CkIndex_Main::terminate(), mainProxy));
          return;
        }
        mydt = min(dx,dy)/v * cfl;
        if ((myt + mydt) >= tmax )
          mydt = tmax - myt;

        if(iterations % refine_frequency == 0) doRemeshing();//time to do remeshing
        else doComputationStep();
      }
    };

    entry void exchangeGhosts(){
      serial {
        prepareData4Exchange();
        //send boundaries to neighbors which are 
        //on the same level  as you and to your
        //uncles. For the neighbors which are your
        //nephews, wait until they send their boundaries
        //interpolate them and send them the interpolated
        //boundaries
        for(int i=0; i<NUM_NEIGHBORS; i++)
          sendGhost(i);
      }

      while (imsg < 4) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width]) serial {
          process(iter, dir, width, u1);
          //send interpolated data to nephews
          sendReadyData();
        }
      }
      serial { thisProxy[thisIndex].signalExchangeGhostsCompletion(); }
    };
  };
};
