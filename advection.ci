mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly CProxy_Advection qtree;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly int max_iterations;
  readonly int refine_frequency;

  initproc TurnManualLBOn();
  readonly CProxy_AdvectionGroup ppc;
  readonly bool isInMeshGenerationPhase;

  mainchare Main{
    entry Main(CkArgMsg *m);
    entry void terminate();
    entry void startMeshGeneration();
    entry [reductiontarget] void reportCascadeStats(int cascade_lengths[size], int size);
    entry [reductiontarget] void qdlatency(double elems[size], int size);
    entry [reductiontarget] void remeshlatency(double elems[size], int size);
    entry [reductiontarget] void totalWorkUnits(int total);
  };

  group AdvMap : CkArrayMap {
    entry void AdvMap();
  };

  extern module Advection;
};

module Advection{

  group AdvectionGroup{
    entry AdvectionGroup();
    entry void collectCascades(CkCallback cb);
    entry void reduceLatencies();
    entry void reduceWorkUnits();
    entry void meshGenerationPhaseIsOver();
    entry void notifyMeshUpdate(Decision);
    entry [reductiontarget] void meshUpdateReductionClient(int);
    entry void resetMeshUpdateCounters();
  };


  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(double, double, double, double,
                    double, double, int, int, std::vector<double>,
                    bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], 
                    Decision p3[3*NUM_NEIGHBORS]);
    entry void receiveGhosts(int iter, int dir, int width, double u[width]);
    entry void informParent(int, Decision, int cascade_length);
    entry void recvParentDecision(int cascade_length);
    entry void exchangePhase1Msg(int, Decision, int cascade_length);

    entry void doRemeshing() {
      atomic {
        if (!isInMeshGenerationPhase && isLeaf) exchangeGhosts();
        else signalExchangeGhostsCompletion();
      }
      when signalExchangeGhostsCompletion() atomic{
          makeGranularityDecisionAndCommunicate();
          CkStartQD(CkCallback(CkIndex_Advection::phase1Done(), thisProxy[thisIndex]));
      }
      when phase1Done() atomic{
        doPhase2();
        if (isRoot()) CkStartQD(CkCallback(CkIndex_Advection::iterate(), thisProxy));
      }
    };

    entry void phase2Done() atomic "done phase2"{
        if(isInMeshGenerationPhase){
            meshGenIterations++;
            if(ppc.ckLocalBranch()->meshUpdated && meshGenIterations<20){
                thisProxy[thisIndex].doRemeshing();
                ppc.ckLocalBranch()->resetMeshUpdateCounters();
                return;
            }
        }
        if(isRoot())ppc.meshGenerationPhaseIsOver();
        if(isRoot()){
            itBeginTime=CmiWallTimer();
        }
        iterate();
    };

    entry void startLdb();
    entry void signalExchangeGhostsCompletion();

    entry void doComputationStep(){
      atomic "begin iteration"{
        ppc.ckLocalBranch()->incrementWorkUnitCount();
        if (isRoot()) {
          ckout  << thisIndex.getIndexString().c_str() << " doStep iteration " << iterations 
                 << " dt: " << dt << " mydt: " << mydt << " myt " << myt << endl;
        }
        //iterations++;
        if(isLeaf){
            char fname[100];

            sprintf(fname, "out/out_%s_%d", thisIndex.getIndexString().c_str(), iterations);
            VB(outFile.open(fname););
            VB(logFile << "************************Begin Iteration " << iterations << " on " << thisIndex.getIndexString() << std::endl;);
            exchangeGhosts();
        }
        else
            thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
      when signalExchangeGhostsCompletion() atomic "doWork" {
        if(isLeaf)
            compute();
        iterate();
      }
    };

    entry void iterate() atomic {
      if(isInMeshGenerationPhase && meshGenIterations<max_depth){
        meshGenIterations++;
        thisProxy[thisIndex].doRemeshing();
      } else {
        if(isRoot()) ppc.meshGenerationPhaseIsOver();
        iterations++;
        myt = myt + mydt;
        if(iterations > max_iterations ||  myt>=tmax){
          if (isRoot()) CkStartQD(CkCallback(CkIndex_Main::terminate(), mainProxy));
          return;
        }
        mydt = min(dx,dy)/v * cfl;
        if ((myt + mydt) >= tmax )
          mydt = tmax - myt;

        if(iterations % refine_frequency == 0) doRemeshing();
        else doComputationStep();
      }
    };

    entry void exchangeGhosts(){
      atomic "send whatever data you can"{
        for(int i=0; i<3*NUM_NEIGHBORS; i++)
          nbr_dataSent[i]=false;

        hasReceived.clear();

        for(int j=1; j<=block_height; j++){
          left_edge[j-1] = u[index(1,j)];
          right_edge[j-1] = u[index(block_width,j)];
        }
        FOR_EACH_NEIGHBOR
          sendGhost(i);
        END_FOR
        VB(logFile << "Done Sending Ghosts " << thisIndex.getIndexString() << std::endl;);
      }

      for(imsg = 0; imsg < 4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width]) atomic "receive ghosts" {
          VB(logFile << thisIndex.getIndexString() << " process: " << iter << ", "
             << dir << ", " << width << std::endl;);
          process(iter, dir, width, u1);
          sendReadyData();
        }
      }
      atomic "signal exchange ghost completion"{
        thisProxy[thisIndex].signalExchangeGhostsCompletion();
      }
    };

    entry void phase1Done();
    entry void recvChildData(int, double, double, int, int, std::vector<double>, bool p1[NUM_NEIGHBORS], bool p2[NUM_NEIGHBORS], Decision p3[3*NUM_NEIGHBORS]);

  };
};
