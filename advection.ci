mainmodule Main{

  readonly CProxy_Main mainProxy;
  readonly int block_height;
  readonly int block_width;

  readonly int array_height;
  readonly int array_width;

  readonly int num_chare_rows;
  readonly int num_chare_cols;
        
  readonly int min_depth;
  readonly int max_depth;

  readonly int nframe;

  readonly double xctr;
  readonly double yctr;
  readonly double radius;
        
  readonly double v;

  readonly double ap;
  readonly double an;
  readonly double tmax;
  readonly double dt;
  readonly double cfl;

  readonly map<string, DIR> nbrDirectionMap;
  readonly map<DIR, DIR> reverse_dir_map;

  readonly int max_iterations;
  readonly int refine_frequency;

  mainchare Main{
    entry Main(CkArgMsg *m);
    entry void printTreeInformation(CkVec<QuadIndex>);
    entry void terminate();
    entry void startRunning();
    entry [reductiontarget] void kickPhase2();
  };

  extern module Advection;
};

module Advection{

  message InitRefineMsg {
    double dx;
    double dy;
    double myt;
    double mydt;
    double refined_u[];
    bool parent_nbr_exists[];
    bool parent_nbr_isRefined[];
    DECISION parent_nbr_decision[];
  };

  message ChildDataMsg{
    int childNum;
    int iterations;
    double myt;
    double mydt;
    double child_u[];
    bool child_nbr_exists[];
    bool child_nbr_isRefined[];
    DECISION child_nbr_decision[];
  };


  group PerProcessorChare{
    entry PerProcessorChare();

  };

  include "terminator.hpp";

  array [QuadIndex] Advection {
    entry Advection();
    entry Advection(double, double, double, double);
    entry Advection(InitRefineMsg*);
    entry void printState();

    entry void receiveGhosts(int iter, int dir, int width, double u[width], QuadIndex sender, int tag);
    entry void begin_iteration();
    entry void informParent(int, DECISION);
    entry void recvParentDecision();
    //entry void recvNeighborDecision(DIR);
    //entry void recvStatusUpdateFromParent(int);
    entry void exchangePhase1Msg(int, DECISION);
    //entry void doMeshRestructure();
    entry void done();

    entry void rootTerminated();
    entry [reductiontarget] void phase2Done();
    //entry void phase2bDone();
    entry void startRemesh() {
      if (!hasInitiatedPhase1) {
        atomic "foo" {
          hasInitiatedPhase1 = true;
          CkPrintf("%s in phase 1a iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
          doMeshRestructure();
          terminator->doneSending();
          terminator->msgProcessed();
        }
        when rootTerminated() atomic {
          CkPrintf("%s in phase 1b iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
          contribute(CkCallback(CkIndex_Advection::phase1Done(), thisProxy));
        }
        when phase1Done() atomic {
          CkPrintf("%s in phase 2a iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
          doPhase2();
        }
      }
      else atomic {
          CkPrintf("%s repeat startRemesh iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
        terminator->msgProcessed();
      }
    };
    // Separated for newly created chares from refinement
    entry void startPhase2() {
      atomic {
        CkPrintf("%s in phase 2d iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
        fflush(stdout);
        //contribute(CkCallback(CkReductionTarget(Main, kickPhase2), mainProxy));
        //contribute(CkCallback(CkIndex_Advection::phase2Done(NULL), thisProxy));
      }
      when phase2Done() atomic {
        resetTerminator(true);
        hasInitiatedPhase1=false;
        CkPrintf("%s in phase 2c iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
        fflush(stdout);
        if (shouldDestroy) thisProxy[thisIndex].ckDestroy();
        else {
          if (!isRefined) {
            thisProxy[thisIndex].doStep();
          } else {
            iterations += 5;//refine_frequency;
            CkPrintf("%s in short phase 0 iteration %d\n", thisIndex.getIndexString().c_str(), iterations);
            contribute(CkCallback(CkIndex_Advection::startRemesh(), thisProxy));
            //startRemesh();
          }
        }
      }
    };

    entry void doStep(){
      atomic "begin iteration"{
        ckout  << thisIndex.getIndexString().c_str() << " doStep iteration " << iterations << endl;
        iterations++;
        begin_iteration();
      }
      for(imsg = 0; imsg < 4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                        QuadIndex sender, int tag) atomic "process ghosts" {
          VB(logFile << thisIndex.getIndexString() << " process: " << iter << ", "
                     << dir << ", " << width << ", " << sender.getIndexString() << ", "
                     << tag << std::endl;);
          process(iter, dir, width, u1);
          sendReadyData();
        }
      }
      atomic "doWork" {
        compute_and_iterate();
        iterate();
      }
    };
    entry void phase1Done();
            
    entry void getGhostsAndRefine(){
      /*atomic "initialize imsg"{
        imsg=0;
        for(set<int>::iterator itr=hasReceived.begin(); itr!=hasReceived.end(); itr++){
        if(*itr <= 3)
        imsg++;
        else 
        imsg += 0.5;
        }
        }*/
      for(;imsg<4;) {
        when receiveGhosts[iterations] (int iter, int dir, int width, double u1[width],
                                        QuadIndex sender, int tag) atomic "save ghosts" {
          process(iter, dir, width, u1);
          sendReadyData2RefiningNeighbors();
          cout << "In getGHostsAndRefine: " << thisIndex.getIndexString()
                << " received data from " << dir << ", imsg: " << imsg << ", iteration " << iterations << "\n";
          //terminator->doneSending();
          //terminator->msgProcessed();
        }
      }
      atomic "refine"{
        cout << thisIndex.getIndexString() << " now refining\n";
        refine();
        //terminator->doneSending();
        //terminator->msgProcessed(); // For the self-message that triggered this
      }
    };
    //happens in doPhase2()
    entry void receiveRefGhosts(int ,int, int width, double u[width]);
    entry void getAndSendGhost(){
      atomic{
        VB(logFile << "getAndSendGhost called" << endl;); 
        //terminator->msgProcessed(); // For the self-message that triggered this
      }
      when receiveRefGhosts[iterations] (int iter, int dir, int width,
                                         double u1[width]) atomic "interpolate and send"{
        process(iter, dir, width, u1);
        sendReadyData2RefiningNeighbors();//interpolateAndSend(dir);
        //terminator->doneSending();
        //terminator->msgProcessed();
      }
    };

    //for LiveViz
    entry void requestNextFrame(liveVizRequestMsg *m);
    entry void free_memory();
    entry void doPhase2();
    entry void recvChildData(ChildDataMsg*);

    // For termination detection
    entry void needAck(QuadIndex predecessor, unsigned int count);
    entry void gotAck(unsigned int count);
  };
};
